# Job ID-Based Question Filtering

## Overview

The code-sandbox now supports filtering questions by **job ID**. Questions generated by `qa_gen_spice` are tagged with a specific job ID (referencing a job posting), and code-sandbox fetches questions relevant to that job.

## How It Works

### 1. Question Generation (qa_gen_spice)

When generating questions in `qa_gen_spice`, questions include a `job_id` field that references a specific job posting:

```python
# In qa_gen_spice
question = DSAQuestion(
    question_type="code",
    title="Two Sum Problem",
    description="...",
    difficulty="medium",
    topics=["arrays", "hash-table"],
    job_id="60d5ec49f1a2c8b1f8e4e1a1",  # ← Job ID from job posting
    test_cases=[...],
    # ... other fields
)
```

The `job_id` field should reference a job posting ID from your jobs database (e.g., from JD_Parser service).

### 2. Question Retrieval (code-sandbox)

Questions are filtered by job ID when fetching:

#### Get Code Question by Job ID
```bash
curl -X POST http://localhost:8000/api/v1/code/get-question \
  -H "Content-Type: application/json" \
  -d '{
    "mode": "code",
    "user_id": "user123",
    "difficulty": "medium",
    "job_id": "60d5ec49f1a2c8b1f8e4e1a1"
  }'
```

#### Get Aptitude Question by Job ID
```bash
curl -X POST http://localhost:8000/api/v1/aptitude/get-question \
  -H "Content-Type: application/json" \
  -d '{
    "mode": "apti",
    "user_id": "user123",
    "difficulty": "easy",
    "job_id": "60d5ec49f1a2c8b1f8e4e1a2"
  }'
```

## API Endpoints

### 1. Get Question Statistics by Job ID

```http
GET /api/v1/questions/stats?job_id=60d5ec49f1a2c8b1f8e4e1a1
```

**Response:**
```json
{
  "total_questions": 45,
  "job_id": "60d5ec49f1a2c8b1f8e4e1a1",
  "code_questions": {
    "total": 30,
    "easy": 10,
    "medium": 15,
    "hard": 5
  },
  "aptitude_questions": {
    "total": 15,
    "easy": 8,
    "medium": 5,
    "hard": 2
  }
}
```

### 2. Get All Available Job IDs

```http
GET /api/v1/questions/job-ids
```

**Response:**
```json
{
  "total_job_ids": 5,
  "job_ids": [
    {
      "job_id": "60d5ec49f1a2c8b1f8e4e1a1",
      "total_questions": 45,
      "code_questions": 30,
      "aptitude_questions": 15
    },
    {
      "job_id": "60d5ec49f1a2c8b1f8e4e1a2",
      "total_questions": 35,
      "code_questions": 25,
      "aptitude_questions": 10
    }
  ]
}
```

## Request Schema

### QuestionRequest Model

```python
{
  "mode": "code" | "apti",        # Required
  "user_id": "string",             # Required
  "difficulty": "easy" | "medium" | "hard",  # Optional
  "topic": "string",               # Optional
  "job_id": "string"               # Optional - Job posting ID
}
```

## Use Cases

### 1. Job-Specific Interview Prep

Prepare candidates with questions tailored to the specific job posting they're applying for:

```python
# For a specific job posting
response = requests.post(
    "http://localhost:8000/api/v1/code/get-question",
    json={
        "mode": "code",
        "user_id": "candidate_123",
        "job_id": "60d5ec49f1a2c8b1f8e4e1a1",  # Job posting ID
        "difficulty": "medium"
    }
)
```

### 2. Job-Specific Assessment

Create assessments for specific job openings:

```python
# Get all questions for a job posting
job_id = "60d5ec49f1a2c8b1f8e4e1a1"
questions = []

# Fetch code questions
for difficulty in ["easy", "medium", "hard"]:
    q = fetch_question(job_id=job_id, question_type="code", difficulty=difficulty)
    if q:
        questions.append(q)

# Fetch aptitude questions
for difficulty in ["easy", "medium"]:
    q = fetch_question(job_id=job_id, question_type="apti", difficulty=difficulty)
    if q:
        questions.append(q)
```

### 3. Integration with Job Postings

Link questions directly to job postings from JD_Parser:

```python
# Step 1: Get job from JD_Parser
job = get_job_from_jd_parser("60d5ec49f1a2c8b1f8e4e1a1")

# Step 2: Check if questions exist for this job
stats = requests.get(
    f"http://localhost:8000/api/v1/questions/stats?job_id={job['_id']}"
).json()

# Step 3: Fetch questions
if stats['total_questions'] > 0:
    question = fetch_question(job_id=job['_id'])
```

## Database Schema

Questions in MongoDB (`qa_gen_db.dsa_questions`) include:

```json
{
  "_id": "ObjectId",
  "question_type": "code" | "apti",
  "job_id": "60d5ec49f1a2c8b1f8e4e1a1",  // ← Links to job posting
  "title": "Question Title",
  "description": "...",
  "difficulty": "easy" | "medium" | "hard",
  "topics": ["arrays", "strings"],
  "test_cases": [...],
  "created_at": "2026-02-07T10:00:00Z"
}
```

## Filtering Logic

Questions are filtered with **AND** logic:

```python
# All filters are applied together
query = {
    "question_type": "code",       # Always required
    "difficulty": "medium",         # If provided
    "topics": "arrays",             # If provided
    "job_id": "60d5ec49f1a2c8b1f8e4e1a1"  # If provided
}
```

## Error Handling

### No Questions Found

If no questions match the criteria:

```json
{
  "status_code": 404,
  "detail": "No code questions available matching the criteria (difficulty=medium, topic=arrays, job_id=60d5ec49f1a2c8b1f8e4e1a1). Please generate questions using qa_gen_spice service first."
}
```

**Resolution:**
1. Check available questions: `GET /api/v1/questions/stats?job_id=60d5ec49f1a2c8b1f8e4e1a1`
2. Generate questions for that job using qa_gen_spice
3. Retry with broader filters (remove topic or difficulty)

## Best Practices

### 1. Check Available Job IDs First

Before filtering by job ID, check what's available:

```python
job_ids = get_available_job_ids()
if selected_job_id in [j['job_id'] for j in job_ids['job_ids']]:
    # Safe to filter by this job ID
    questions = fetch_questions(job_id=selected_job_id)
```

### 2. Fallback Strategy

If no questions found for specific job, fall back to general questions:

```python
# Try with job ID
question = fetch_question(job_id="60d5ec49f1a2c8b1f8e4e1a1", difficulty="medium")

if not question:
    # Fallback: Try without job ID
    question = fetch_question(difficulty="medium")
```

### 3. Combined Filtering

Use multiple filters for precise question selection:

```python
# Job-specific, topic-specific, difficulty-specific
question = fetch_question(
    job_id="60d5ec49f1a2c8b1f8e4e1a1",
    topic="databases",
    difficulty="hard"
)
```

## Testing

### Test Job ID Filtering

```python
# example_usage.py demonstrates job ID usage
python example_usage.py

# Expected output:
# ✓ Available job IDs: ['60d5ec49f1a2c8b1f8e4e1a1', ...]
# ✓ Using job ID: 60d5ec49f1a2c8b1f8e4e1a1
# ✓ Questions available: 45 total
```

### Manual Testing

```bash
# 1. Check available job IDs
curl http://localhost:8000/api/v1/questions/job-ids

# 2. Get stats for specific job
curl "http://localhost:8000/api/v1/questions/stats?job_id=60d5ec49f1a2c8b1f8e4e1a1"

# 3. Fetch question for job
curl -X POST http://localhost:8000/api/v1/code/get-question \
  -H "Content-Type: application/json" \
  -d '{"mode":"code","user_id":"test","job_id":"60d5ec49f1a2c8b1f8e4e1a1"}'
```

## Integration with JD_Parser

Questions can be linked to job postings from the JD_Parser service:

```python
# In qa_gen_spice, when generating questions:
from jd_parser import get_job_posting

# Fetch job details
job = get_job_posting("60d5ec49f1a2c8b1f8e4e1a1")

# Generate questions based on job requirements
questions = generate_questions_for_job(
    job_id=job["_id"],
    skills=job.get("skills", []),
    experience_level=job.get("experience_level", "mid"),
    responsibilities=job.get("responsibilities", [])
)

# Store questions with job_id
for question in questions:
    question.job_id = job["_id"]
    store_question(question)
```

## Summary

| Feature | Endpoint | Parameters |
|---------|----------|------------|
| Get questions by job ID | POST `/code/get-question` | `job_id` in body |
| Stats by job ID | GET `/questions/stats` | `?job_id=...` |
| List all job IDs | GET `/questions/job-ids` | None |

**Job ID filtering enables:**
- ✅ Job-specific interview preparation
- ✅ Targeted skill assessment per job posting
- ✅ Personalized question selection
- ✅ Better question-to-job mapping
- ✅ Integration with job posting systems

## Migration from Job Role

If you previously used `job_role`, update to `job_id`:

```python
# Old (job_role)
question = fetch_question(job_role="Software Engineer")

# New (job_id)
question = fetch_question(job_id="60d5ec49f1a2c8b1f8e4e1a1")
```

Database migration:
```python
from pymongo import MongoClient

client = MongoClient("mongodb://...")
db = client["qa_gen_db"]

# If you have job_role field, you might want to map it to actual job IDs
# This requires knowledge of your job postings
job_role_to_id_map = {
    "Software Engineer": "60d5ec49f1a2c8b1f8e4e1a1",
    "Data Engineer": "60d5ec49f1a2c8b1f8e4e1a2",
    # ... etc
}

for job_role, job_id in job_role_to_id_map.items():
    db.dsa_questions.update_many(
        {"job_role": job_role},
        {
            "$set": {"job_id": job_id},
            "$unset": {"job_role": ""}
        }
    )
```
